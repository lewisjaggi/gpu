#include <cudaTools.h>
#include <Device.h>
#include <Grid.h>
#include <MathTools.h>
#include <iostream>

#include "host/KernelConvolutionHost.h"

using std::cout;
using std::endl;

/*----------------------------------------------------------------------*\
 |*			Declaration 					*|
 \*---------------------------------------------------------------------*/

/*--------------------------------------*\
 |*		Public			*|
 \*-------------------------------------*/
__host__ bool isKernelConvolutionOK(const Grid& grid, int _w, int _h, int _radius, float* _tabKernel, uchar* _tabInput, uchar* _tabOutputSupposed);
__host__ bool isKernelConvolutionOK();

/*----------------------------------------------------------------------*\
 |*			Implementation 					*|
 \*---------------------------------------------------------------------*/

/*--------------------------------------*\
 |*		Public			*|
 \*-------------------------------------*/
bool isKernelConvolutionOK(const Grid& grid, int _w, int _h, int _radius, float* _tabKernel, uchar* _tabInput, uchar* _tabOutputSupposed)
    {
    int w = _w;
    int h = _h;
    int radius = _radius;

    uchar* tabInput = _tabInput;

    int sizeLine = (2 * radius + 1);

    float* tabKernel = _tabKernel;

    // Print debug
    for (int i = 0; i < sizeLine * sizeLine; i++)
	{
	if (i % sizeLine == 0)
	    {
	    std::cout << std::endl;
	    }
	std::cout << tabKernel[i] << " ; ";
	}

    std::cout << std::endl;

    for (int i = 0; i < w * h; i++)
	{
	if (i % w == 0)
	    {
	    std::cout << std::endl;
	    }
	std::cout << (int) tabInput[i] << " ; ";
	}

    std::cout << std::endl;

    uchar tabOutput[w * h];

    uchar* tabOutputSupposed = _tabOutputSupposed;

    KernelConvolutionHost kernelConvolutionHost(grid, tabInput, tabOutput, w, h, radius, tabKernel);
    kernelConvolutionHost.run();

    bool isOk = false;

    for (int i = 0; i < w * h; i++)
	{
	isOk = MathTools::isEquals((long) tabOutput[i], (long) tabOutputSupposed[i]);
	if (!isOk)
	    break;
	}

    return isOk;
    }

// Kernel
// Kernel 3x3
   //int tabKernel [] = {-1, 1, -1, 1, 1, 1, -1, 1, -1}; // V_Test
//    int tabKernel[] = { 1, 1, 1, 1, 1, 1, 1, 1, 1 }; // V1
//    int tabKernel[] = { 0, 0, 0, 0, 1, 0, 0, 0, 0 }; // V1 Sans effet
//    int tabKernel [] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 }; //V3-4 Convulotion X
//    int tabKernel [] = { 0.111, 0.111, 0.111, 0.111, 0, 0.111, 0.111, 0.111, 0.111}; //V2a,b,c FLOU

   // Kernel 5x5
//    int tabKernel [] = { 0,0,0,0,0, 0,0,0,0,0, 0,0,1,0,0, 0,0,0,0,0, 0,0,0,0,0}; //V1
//    int tabKernel [] = { -1,0,0,0,1, -1,0,0,0,1, -1,0,0,0,1, -1,0,0,0,1, -1,0,0,0,1}; //V3-4 Convolution X

// tabOutputSupposed
//    uchar tabOutputSupposed [] = { 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0 }; V3-4 5x5 (MARCHE PAS)
    // V3-4 10x10 pour kernel 3x3
    //uchar tabOutputSupposed [] = {0,0,0,0,2,2,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,3,3,0,0,0,0, 0,0,0,0,2,2,0,0,0,0};
    // V3-4 10x10 pour kernel 5x5
//    uchar tabOutputSupposed [] = {0,0,0,3,3,3,3,0,0,0, 0,0,0,4,4,4,4,0,0,0, 0,0,0,5,5,5,5,0,0,0, 0,0,0,5,5,5,5,0,0,0, 0,0,0,5,5,5,5,0,0,0, 0,0,0,5,5,5,5,0,0,0, 0,0,0,5,5,5,5,0,0,0, 0,0,0,5,5,5,5,0,0,0, 0,0,0,4,4,4,4,0,0,0, 0,0,0,3,3,3,3,0,0,0};
//    uchar tabOutputSupposed [w*h]; // V1

bool isKernelConvolutionV1_OK()
    {
    int coreMP = Device::getCoreCountMP();

    dim3 dg = dim3(64, 1, 1);
    dim3 db = dim3(coreMP * 4, 1, 1);
    Grid grid(dg, db);

    int w = 32;
    int h = 32;
    int radius = 2;

    float tabKernel[] =
	{
	0, 0, 0, 0, 0,
	0, 0, 0, 0, 0,
	0, 0, 1, 0, 0,
	0, 0, 0, 0, 0,
	0, 0, 0, 0, 0,
	};
    uchar tabInput[w * h];
    for (int i = 0; i < h; i++)
	{
	for (int j = 0; j < w; j++)
	    {
	    tabInput[i * w + j] = 1;
	    }
	}

    return isKernelConvolutionOK(grid, w, h, radius, tabKernel, tabInput, tabInput);
    }

bool isKernelConvolutionV3_4_OK()
    {
    int coreMP = Device::getCoreCountMP();

    dim3 dg = dim3(64, 1, 1);
    dim3 db = dim3(coreMP * 4, 1, 1);
    Grid grid(dg, db);

    int w = 32;
    int h = 32;
    int radius = 2;

    float tabKernel[] =
	{
	-1, 0, 0, 0, 1,
	-1, 0, 0, 0, 1,
	-1, 0, 0, 0, 1,
	-1, 0, 0, 0, 1,
	-1, 0, 0, 0, 1
	};

    uchar tabInput[w * h];
    for (int i = 0; i < h; i++) // V3-4
	{
	for (int j = 0; j < w; j++)
	    {
	    tabInput[i * w + j] = 1;
	    if (j < w / 2)
		{
		tabInput[i * w + j] = 0;
		}
	    }
	}

//    uchar tabOutputSupposed [] = {
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
//    		0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,3,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    uchar tabOutputSupposed [] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,5,5,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0};


    return isKernelConvolutionOK(grid, w, h, radius, tabKernel, tabInput, tabOutputSupposed);
    }
